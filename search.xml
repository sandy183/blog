<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[LLDB调试命令-个人用无序版]]></title>
      <url>http://sajinwu.github.io/20151113LLDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4-%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%97%A0%E5%BA%8F%E7%89%88/</url>
      <content type="html"><![CDATA[<p>使用前提：<br>1.既然是调试命令，理所当然的，程序模式应该选择Debug模式。<br>2.在Debug模式下，如果你的程序在运行中崩溃（Crash）掉，那么恭喜你，使用lldb调试的机会来了。</p>
<h5 id="bt_:_打印出最后一次调用堆栈信息">bt : 打印出最后一次调用堆栈信息</h5><h5 id="set:设置临时断点">set:设置临时断点</h5><p>用法:</p>
<ul>
<li>如果想在<strong>某个文件中的某行</strong>设置一个断点，可使用以下命令:</li>
</ul>
<blockquote>
<p>(lldb) breakpoint set –file foo.c –line 12</p>
</blockquote>
<ul>
<li>如果想给某个<strong>函数</strong>设置断点，可使用以下命令：</li>
</ul>
<blockquote>
<p>(lldb) breakpoint set –name foo</p>
</blockquote>
<ul>
<li>如果想给<strong>C++</strong>中所有命名为foo的方法设置断点，可以使用以下命令：</li>
</ul>
<blockquote>
<p>(lldb) breakpoint set –method foo</p>
</blockquote>
<ul>
<li>如果想给<strong>Objective-C</strong>中所有命名为alignLeftEdges:的选择器设置断点，则可以使用以下命令：</li>
</ul>
<blockquote>
<p>(lldb) breakpoint set –selector alignLeftEdges:</p>
</blockquote>
<ul>
<li>我们可以使用<strong>—shlib</strong> 来将断点限定在一个特定的可执行库中：</li>
</ul>
<blockquote>
<p>(lldb) breakpoint set –shlib foo.dylib –name foo</p>
</blockquote>
<p>看吧，断点设置命令还是很强大的。</p>
<a id="more"></a>
<p>如果我们想查看程序中所有的断点，则可以使用breakpoint list命令，如下所示:</p>
<blockquote>
<p>(lldb) breakpoint list<br>Current breakpoints:<br>1: file = ‘../Business/MainView/controller/HomePageViewController.m’, line = 146, locations = 1, resolved = 1, hit count = 1<br>  1.1: where = Recruitment`-[HomePageViewController createTableView] + 495 at HomePageViewController.m:146, address = 0x000000010c4dccdf, resolved, hit count = 1 </p>
</blockquote>
<p>从上面的输出结果可以看出，一个断点一般有两部分：</p>
<p>1.断点的逻辑规范，这一部分是用户提供给breakpoint set命令的。<br>2.与规范匹配的断点的位置。</p>
<p>breakpoint list命令输出列表显示每个逻辑断点都有一个整数标识，如上所示断点标识为1。而每个位置也会有一个标识，如上所示的1.1<br> 不管是逻辑断点产生的所有位置，还是逻辑断点解析的任何特定位置，我们都可以使用断点触发命令来对其进行删除、禁用、设置条件或忽略计数操作。例如，如果我们想添加一个命令，以在LLDB命中断点1.1时打印跟踪栈，则可以执行以下命令:</p>
<blockquote>
<p>(lldb) breakpoint command add 1.1<br>Enter your debugger command(s). Type ‘DONE’ to end.<br>> bt<br>> DONE</p>
</blockquote>
<p>如果想更详细地了解”breakpoint command add”命令的使用，可以使用help帮助系统来查看</p>
<p>当然这里记了这么多，没什么乱用，因为真正会在终端下使用<strong>LLDB</strong>的人会看我的笔记？咱们还是看看<strong>Xcode</strong>里面怎么用吧</p>
<ul>
<li>打印-最实用的，<br>打印变量的值可以使用print命令，该命令如果打印的是简单类型，则会列出简单类型的类型和值。如果是对象，还会打印出对象指针地址，如下所示：</li>
</ul>
<blockquote>
<p>(lldb) print a<br>(NSInteger) $0 = 0<br>(lldb) print b<br>(NSInteger) $1 = 0<br>(lldb) print str<br>(NSString <em>) $2 = 0x0000000100001048 @”abc”<br>(lldb) print url<br>(NSURL </em>) $3 = 0x0000000100206cc0 @”abc”</p>
</blockquote>
<p>在输出结果中我们还能看到类似于\$0,\$1这样的符号，我们可以将其看作是指向对象的一个引用，我们在控制面板中可以直接使用这个符号来操作对应的对象，这些东西存在于LLDB的全名空间中，目的是为了辅助调试。如下所示:</p>
<blockquote>
<p>(lldb) exp $0 = 100 </p>
<p>(NSInteger) $9 = 100</p>
<p>(lldb) p a<br>(NSInteger) $10 = 100</p>
</blockquote>
<p>另外$后面的数值是递增的，每打印一个与对象相关的命令，这个值都会加1<br>上面的print命令会打印出对象的很多信息，如果我们只想查看对象的值的信息，则可以使用po(print object的缩写)命令，如下所示：</p>
<blockquote>
<p>(lldb)po str<br>abc</p>
</blockquote>
<p>当然，po命令是”exp -O —“命令的别名，使用”exp -O —”能达到同样的效果<br>对于简单类型，我们还可以为其指定不同的打印格式，其命令格式是print/，如下所示：</p>
<blockquote>
<p>(lldb) p/x a<br>(NSInteger) $13 = 0x0000000000000064</p>
</blockquote>
<p>格式的完整清单可以参考<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="external">Output Formats</a></p>
<ul>
<li>expression</li>
</ul>
<p>在开发中，我们经常会遇到这样一种情况：我们设置一个视图的背景颜色，运行后发现颜色不好看。嗯，好吧，在代码里面修改一下，再编译运行一下，嗯，还是不好看，然后再修改吧～～这样无形中浪费了我们大把的时间。在这种情况下，expression命令强大的功能就能体现出来了，它不仅会改变调试器中的值，还改变了程序中的实际值。我们先来看看实际效果，如下所示:</p>
<blockquote>
<p>(lldb) exp a = 10<br>(NSInteger) $0 = 10</p>
<p>(lldb) exp b = 100<br>(NSInteger) $1 = 100<br>2015-01-25 14:00:41.313 test[18064:71466] a + b = 110, abc</p>
</blockquote>
<p>expression命令的功能不仅于此，正如上面的po命令，其实际也是”expression -O —“命令的别名。更详细使用可以参考<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="external">Evaluating Expressions</a>.</p>
<ul>
<li>image(并非图片)</li>
</ul>
<p>image命令的用法也挺多，首先可以用它来查看工程中使用的库，如下所示：</p>
<blockquote>
<p>(lldb) image list<br>[  0] 432A6EBF-B9D2-3850-BCB2-821B9E62B1E0 0x0000000100000000 /Users/**/Library/Developer/Xcode/DerivedData/test-byjqwkhxixddxudlnvqhrfughkra/Build/Products/Debug/test<br>[  1] 65DCCB06-339C-3E25-9702-600A28291D0E 0x00007fff5fc00000 /usr/lib/dyld<br>[  2] E3746EDD-DFB1-3ECB-88ED-A91AC0EF3AAA 0x00007fff8d324000 /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation<br>[  3] 759E155D-BC42-3D4E-869B-6F57D477177C 0x00007fff8869f000 /usr/lib/libobjc.A.dylib<br>[  4] 5C161F1A-93BA-3221-A31D-F86222005B1B 0x00007fff8c75c000 /usr/lib/libSystem.B.dylib<br>[  5] CBD1591C-405E-376E-87E9-B264610EBF49 0x00007fff8df0d000 /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation<br>[  6] A260789B-D4D8-316A-9490-254767B8A5F1 0x00007fff8de36000 /usr/lib/libauto.dylib </p>
</blockquote>
<p>我们还可以用它来查找可执行文件或共享库的原始地址，这一点还是很有用的，当我们的程序崩溃时，我们可以使用这条命令来查找崩溃所在的具体位置，如下所示：</p>
<blockquote>
<p>NSArray *array = @[@1, @2];<br>NSLog(@”item 3: %@”, array[2]);</p>
</blockquote>
<p>这段代码在运行后会抛出如下异常：</p>
<blockquote>
<p>2015-01-25 14:12:01.007 test[18122:76474] <strong><em> Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘</em></strong> -[<strong>NSArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 1]’<br><em>*</em> First throw call stack:<br>(<br> 0   CoreFoundation                      0x00007fff8e06f66c </strong>exceptionPreprocess + 172<br>1   libobjc.A.dylib                     0x00007fff886ad76e objc_exception_throw + 43<br>2   CoreFoundation                      0x00007fff8df487de -[__NSArrayI objectAtIndex:] + 190<br>3   test                                0x0000000100000de0 main + 384<br> 4   libdyld.dylib                       0x00007fff8f1b65c9 start + 1<br>)<br>libc++abi.dylib: terminating with uncaught exception of type NSException</p>
</blockquote>
<p>根据以上信息，我们可以判断崩溃位置是在main.m文件中，要想知道具体在哪一行，可以使用以下命令：</p>
<blockquote>
<p>(lldb) image lookup –address 0x0000000100000de0<br> Address: test[0x0000000100000de0] (test.<strong>TEXT.</strong>text + 384)<br>Summary: test`main + 384 at main.m:23</p>
</blockquote>
<p>可以看到，最后定位到了main.m文件的第23行，正是我们代码所在的位置。<br>我们还可以使用image lookup命令来查看具体的类型，如下所示:</p>
<blockquote>
<p>(lldb) image lookup –type NSURL<br>Best match found in /Users/<em>*/Library/Developer/Xcode/DerivedData/test-byjqwkhxixddxudlnvqhrfughkra/Build/Products/Debug/test:<br>id = {0x100000157}, name = “NSURL”, byte-size = 40, decl = NSURL.h:17, clang_type = “@interface NSURL : NSObject{<br>NSString </em> _urlString;<br>NSURL <em> _baseURL;<br>void </em> _clients;<br>void <em> _reserved;<br>}<br>@property ( readonly,getter = absoluteString,setter = <null selector="">,nonatomic ) NSString </null></em> absoluteString;<br>@property ( readonly,getter = relativeString,setter = <null selector="">,nonatomic ) NSString <em> relativeString;<br>@property ( readonly,getter = baseURL,setter = <null selector="">,nonatomic ) NSURL </null></em> baseURL;<br>@property ( readonly,getter = absoluteURL,setter = <null selector="">,nonatomic ) NSURL <em> absoluteURL;<br>@property ( readonly,getter = scheme,setter = <null selector="">,nonatomic ) NSString </null></em> scheme;<br>@property ( readonly,getter = resourceSpecifier,setter = <null selector="">,nonatomic ) NSString <em> resourceSpecifier;<br>@property ( readonly,getter = host,setter = <null selector="">,nonatomic ) NSString </null></em> host;<br>@property ( readonly,getter = port,setter = <null selector="">,nonatomic ) NSNumber <em> port;<br>@property ( readonly,getter = user,setter = <null selector="">,nonatomic ) NSString </null></em> user;<br>@property ( readonly,getter = password,setter = <null selector="">,nonatomic ) NSString <em> password;<br>@property ( readonly,getter = path,setter = <null selector="">,nonatomic ) NSString </null></em> path;<br>@property ( readonly,getter = fragment,setter = <null selector="">,nonatomic ) NSString <em> fragment;<br>@property ( readonly,getter = parameterString,setter = <null selector="">,nonatomic ) NSString </null></em> parameterString;<br>@property ( readonly,getter = query,setter = <null selector="">,nonatomic ) NSString <em> query;<br>@property ( readonly,getter = relativePath,setter = <null selector="">,nonatomic ) NSString </null></em> relativePath;<br>@property ( readonly,getter = fileSystemRepresentation,setter = <null selector=""> ) const char <em> fileSystemRepresentation;<br>@property ( readonly,getter = isFileURL,setter = <null selector="">,readwrite ) BOOL fileURL;<br>@property ( readonly,getter = standardizedURL,setter = <null selector="">,nonatomic ) NSURL </null></null></em> standardizedURL;<br>@property ( readonly,getter = filePathURL,setter = <null selector="">,nonatomic ) NSURL * filePathURL;<br>@end”</null></null></null></null></null></null></null></null></null></p>
</blockquote>
<p>可以看到，输出结果中列出了NSURL的一些成员变量及属性信息。<br>image命令还有许多其它功能，具体可以参考<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="external">Executable and Shared Library Query Commands</a>;</p>
<p>LLDB 还有很多功能，暂时没有研究就记这么多吧！</p>
<p>参考资料：</p>
<p>[1] <a href="http://lldb.llvm.org/tutorial.html" target="_blank" rel="external">The LLDB Debugger</a></p>
<p>[2]<a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html" target="_blank" rel="external">LLDB Quick Start Guide</a></p>
<p>[3]<a href="http://www.cocoachina.com/ios/20141219/10709.html" target="_blank" rel="external">与调试器共舞 – LLDB 的华尔兹</a></p>
<p>[4]<a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/" target="_blank" rel="external">LLDB调试命令初探</a></p>
<p>[5]<a href="http://www.cocoachina.com/ios/20140530/8619.html" target="_blank" rel="external">NSLog效率低下的原因及尝试lldb断点打印Log</a></p>
<p>[6]<a href="http://www.cocoachina.com/ios/20150126/11021.html" target="_blank" rel="external">浅谈LLDB调试器</a></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博文]]></title>
      <url>http://sajinwu.github.io/20151111%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
      <content type="html"><![CDATA[<h2 id="第一篇博文主要干三件事">第一篇博文主要干三件事</h2><ul>
<li><strong>记一下博客平台的搭建过程</strong></li>
<li><strong>说说有了博客以后要干什么</strong></li>
<li><strong>markdown语法范例</strong></li>
</ul>
<hr>
<h3 id="记一下博客平台的搭建过程">记一下博客平台的搭建过程</h3><ul>
<li>安装</li>
</ul>
<p>前提是必须先安装 Node.js</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$: npm <span class="operator"><span class="keyword">install</span> hexo -<span class="keyword">g</span></span></span><br></pre></td></tr></table></figure>
<p>仅需一步就把 Hexo 本体和所有相依套件安装完毕，很简单吧？</p>
<a id="more"></a>
<ul>
<li>升级</li>
</ul>
<p>更新hexo到最新版</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$: npm <span class="operator"><span class="keyword">update</span> hexo -<span class="keyword">g</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>初始化</li>
</ul>
<blockquote>
<p>$: hexo init </p>
</blockquote>
<p>如果指定 <folder>，便会在目前的资料夹建立一个名为 <folder> 的新资料夹；否则会在目前资料夹初始化。</folder></folder></p>
<ul>
<li>创建新博客</li>
</ul>
<blockquote>
<p>$: hexo new “Hello World”</p>
</blockquote>
<ul>
<li>生成网站</li>
</ul>
<blockquote>
<p>$: hexo generate</p>
</blockquote>
<ul>
<li>启动本地服务器</li>
</ul>
<blockquote>
<p>$: hexo server</p>
</blockquote>
<p>伺服器会跑在 <a href="http://localhost:port" target="_blank" rel="external">http://localhost:port</a> （port 预设为 4000，可在 _config.yml 设定），也可以搭配 Pow 使用：<br>cd ~/.pow<br>ln -s /path/to/myapp</p>
<p>基本使用差不多就是这样子，非常简单。</p>
<hr>
<h3 id="如果你想发布到github上呢">如果你想发布到github上呢</h3><ul>
<li>先注册账号<br>账号相信你已经有了，登录 -&gt; 绑定ssh-key -&gt; 这里不说这些，<a href="http://blog.csdn.net/binyao02123202/article/details/20130891" target="_blank" rel="external">这里有</a></li>
<li><p>建立项目<br>命名规侧：github.user.io</p>
</li>
<li><p>配置hexo<br>打开blog目录下的_config.yml,找到</p>
</li>
</ul>
<pre><code><span class="attribute">deploy</span>:
    <span class="attribute">type</span>: git <span class="comment">// 不要写github,在3.0之后不允许写github了</span>
    <span class="attribute">repo</span>: <span class="comment">// 你的git库地址</span>
    <span class="attribute">branch</span>: <span class="comment">// 分支，一般直接使用默认的master分支</span>
</code></pre><p>在配置好了这几个之后，还有一件很重要的事儿要做，那就是安装hexo专用git</p>
<blockquote>
<p>$ npm install hexo-deployer-git –save</p>
</blockquote>
<p>装好之后剩下的事儿就简单了，生成静态网站之后，执行：</p>
<blockquote>
<p>$ hexo deploy</p>
</blockquote>
<p>然后你就能看到你的博客了，user.github.io<br>就记这么多吧，足以使用了</p>
<hr>
<h3 id="有了博客我要干什么">有了博客我要干什么</h3><ul>
<li>发一些自己在开发中的心得体会</li>
<li>摘录一些别人写的好东西</li>
<li>全当笔记用</li>
</ul>
<hr>
<h3 id="markdown语法范例">markdown语法范例</h3><h1 id="一级标题">一级标题</h1><h2 id="二级标题">二级标题</h2><h6 id="六级标题">六级标题</h6><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>
<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>
<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>
<li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="external">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="external">离线Chrome App</a>，支持移动端 Web；</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>
</ul>
<hr>
<p>[TOC]</p>
<h2 id="Markdown简介">Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="external">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Cmd + /</code>查看帮助。 </p>
<h3 id="代码块">代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="decorator">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span><br><span class="line"><span class="prompt">... </span>prompt'''</span></span><br></pre></td></tr></table></figure>
<h3 id="LaTeX_公式">LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格">表格</h3><table>
<thead>
<tr>
<th style="text-align:left">Item</th>
<th style="text-align:right">Value</th>
<th style="text-align:center">Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 USD</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 USD</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 USD</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="流程图">流程图</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st=&#62;start: Start&#10;e=&#62;end&#10;op=&#62;operation: My Operation&#10;cond=&#62;condition: Yes or No?&#10;&#10;st-&#62;op-&#62;cond&#10;cond(yes)-&#62;e&#10;cond(no)-&#62;op</span><br></pre></td></tr></table></figure>
<p>以及时序图:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alice-&#62;Bob: Hello Bob, how are you?&#10;Note right of Bob: Bob thinks&#10;Bob--&#62;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">语法</a>。</p>
</blockquote>
<h3 id="复选框">复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li>[x] 已完成事项</li>
<li>[ ] 待办事项1</li>
<li>[ ] 待办事项2</li>
</ul>
<blockquote>
<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>
</blockquote>
<h2 id="印象笔记相关">印象笔记相关</h2><h3 id="笔记本和标签">笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>
<h3 id="笔记标题">笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>
<h3 id="快捷编辑">快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>
<blockquote>
<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>
</blockquote>
<h3 id="数据同步">数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>
<blockquote>
<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>
</blockquote>
<h3 id="离线存储">离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>
</blockquote>
<h2 id="编辑器相关">编辑器相关</h2><h3 id="设置">设置</h3><p>右侧系统菜单（快捷键<code>Cmd + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键">快捷键</h3><p>帮助    <code>Cmd + /</code><br>同步文档    <code>Cmd + S</code><br>创建文档    <code>Cmd + Opt + N</code><br>最大化编辑器    <code>Cmd + Enter</code><br>预览文档 <code>Cmd + Opt + Enter</code><br>文档管理    <code>Cmd + O</code><br>系统菜单    <code>Cmd + M</code> </p>
<p>加粗    <code>Cmd + B</code><br>插入图片    <code>Cmd + G</code><br>插入链接    <code>Cmd + L</code><br>提升标题    <code>Cmd + H</code></p>
<h2 id="关于收费">关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>
<h2 id="反馈与建议">反馈与建议</h2><ul>
<li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="external">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="external">@GGock</a></li>
<li>邮箱：<a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x68;&#x75;&#x73;&#x74;&#x67;&#x6f;&#x63;&#x6b;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#x68;&#x75;&#x73;&#x74;&#x67;&#x6f;&#x63;&#x6b;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;</a></li>
</ul>
<hr>
<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
<p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="external">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="external">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>]]></content>
    </entry>
    
  
  
</search>
